# PostgreSQL Integration Plan

## Overview

This plan outlines the steps to migrate from H2 (embedded) to PostgreSQL as the database for the Flowable BPM application. The integration will support both development (H2) and production (PostgreSQL) modes using Spring profiles.

---

## Current State

| Aspect | Current Setup |
|--------|---------------|
| Database | H2 (embedded file-based) |
| Schema Location | `/backend/src/main/resources/schema.sql` |
| Configuration | `/backend/src/main/resources/application.yml` |
| Driver | `org.h2.Driver` |
| Connection URL | `jdbc:h2:file:./data/flowabledb` |

### Current Tables
1. `document` - Process-level variables (90+ columns)
2. `grid_rows` - Grid data rows (90+ columns)
3. `column_mapping` - Dynamic field-to-column mappings
4. `process_config` - Per-process persistence settings

---

## Implementation Steps

### Step 1: Add PostgreSQL Driver Dependency

**File:** `/backend/pom.xml`

Add the PostgreSQL JDBC driver alongside the existing H2 driver:

```xml
<!-- PostgreSQL Database -->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
```

---

### Step 2: Create PostgreSQL-Compatible Schema

**File:** `/backend/src/main/resources/schema-postgresql.sql` (new file)

Key syntax differences from H2:
| H2 Syntax | PostgreSQL Syntax |
|-----------|-------------------|
| `BIGINT AUTO_INCREMENT` | `BIGSERIAL` or `BIGINT GENERATED BY DEFAULT AS IDENTITY` |
| `DOUBLE` | `DOUBLE PRECISION` |
| `CREATE INDEX IF NOT EXISTS` | Same (supported in PostgreSQL 9.5+) |
| `CREATE TABLE IF NOT EXISTS` | Same (supported) |

The PostgreSQL schema will use:
- `BIGSERIAL` for auto-incrementing primary keys
- `DOUBLE PRECISION` for float columns
- `TEXT` for VARCHAR columns (PostgreSQL has no practical limit on TEXT)
- `TIMESTAMP` for datetime columns (same as H2)

---

### Step 3: Configure Spring Profiles

**File:** `/backend/src/main/resources/application.yml`

Restructure to support multiple database profiles:

```yaml
spring:
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:h2}

  # Common JPA settings
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: false

---
# H2 Profile (Development)
spring:
  config:
    activate:
      on-profile: h2
  datasource:
    url: jdbc:h2:file:./data/flowabledb;DB_CLOSE_DELAY=-1
    driver-class-name: org.h2.Driver
    username: sa
    password:
  sql:
    init:
      mode: always
      schema-locations: classpath:schema.sql
  h2:
    console:
      enabled: true

---
# PostgreSQL Profile (Production)
spring:
  config:
    activate:
      on-profile: postgresql
  datasource:
    url: ${SPRING_DATASOURCE_URL}
    driver-class-name: org.postgresql.Driver
    username: ${SPRING_DATASOURCE_USERNAME}
    password: ${SPRING_DATASOURCE_PASSWORD}
  sql:
    init:
      mode: always
      schema-locations: classpath:schema-postgresql.sql
  h2:
    console:
      enabled: false
```

---

### Step 4: Update Environment Configuration

**File:** `.env.example`

Add PostgreSQL configuration variables:

```bash
# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================

# Active Spring profile: 'h2' for development, 'postgresql' for production
SPRING_PROFILES_ACTIVE=h2

# PostgreSQL Configuration (when SPRING_PROFILES_ACTIVE=postgresql)
SPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/flowable
SPRING_DATASOURCE_USERNAME=flowable
SPRING_DATASOURCE_PASSWORD=your_secure_password

# Connection pool settings (optional, defaults in application.yml)
SPRING_DATASOURCE_HIKARI_MINIMUM_IDLE=2
SPRING_DATASOURCE_HIKARI_MAXIMUM_POOL_SIZE=10
```

---

### Step 5: Create PostgreSQL Schema File

**File:** `/backend/src/main/resources/schema-postgresql.sql`

Full PostgreSQL-compatible DDL:

```sql
-- Business Tables Schema for PostgreSQL

-- 1. DOCUMENT TABLE
CREATE TABLE IF NOT EXISTS document (
    id BIGSERIAL PRIMARY KEY,
    process_instance_id VARCHAR(64) NOT NULL,
    business_key VARCHAR(255),
    process_definition_key VARCHAR(255),
    process_definition_name VARCHAR(255),

    -- 30 VARCHAR columns (TEXT in PostgreSQL)
    varchar_1 TEXT, varchar_2 TEXT, ... varchar_30 TEXT,

    -- 30 FLOAT columns
    float_1 DOUBLE PRECISION, ... float_30 DOUBLE PRECISION,

    -- 30 DATETIME columns
    datetime_1 TIMESTAMP, ... datetime_30 TIMESTAMP,

    -- Audit columns
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(255),
    updated_by VARCHAR(255),

    CONSTRAINT uk_document_process_instance UNIQUE (process_instance_id)
);

-- Similar for grid_rows, column_mapping, process_config tables
```

---

### Step 6: Handle Flowable Engine Tables

Flowable will auto-create its tables on PostgreSQL. Ensure:
- `flowable.database-schema-update: true` (already configured)
- Flowable supports PostgreSQL natively

---

### Step 7: Connection Pool Optimization

Update HikariCP settings for PostgreSQL production workloads:

```yaml
spring:
  datasource:
    hikari:
      minimum-idle: ${SPRING_DATASOURCE_HIKARI_MINIMUM_IDLE:2}
      maximum-pool-size: ${SPRING_DATASOURCE_HIKARI_MAXIMUM_POOL_SIZE:10}
      idle-timeout: 300000
      connection-timeout: 30000
      max-lifetime: 1800000
      pool-name: FlowableHikariPool
```

---

### Step 8: Update Docker Compose (Optional)

**File:** `docker-compose.yml` or `docker-compose.prod.yml`

Add PostgreSQL service for local testing:

```yaml
services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: flowable
      POSTGRES_USER: flowable
      POSTGRES_PASSWORD: flowable
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U flowable"]
      interval: 5s
      timeout: 5s
      retries: 5

  backend:
    environment:
      SPRING_PROFILES_ACTIVE: postgresql
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/flowable
      SPRING_DATASOURCE_USERNAME: flowable
      SPRING_DATASOURCE_PASSWORD: flowable
    depends_on:
      postgres:
        condition: service_healthy

volumes:
  postgres_data:
```

---

## File Changes Summary

| File | Action | Description |
|------|--------|-------------|
| `backend/pom.xml` | Modify | Add PostgreSQL driver dependency |
| `backend/src/main/resources/application.yml` | Modify | Add profile-based configuration |
| `backend/src/main/resources/schema-postgresql.sql` | Create | PostgreSQL-compatible DDL |
| `.env.example` | Modify | Add PostgreSQL environment variables |
| `docker-compose.yml` | Modify (optional) | Add PostgreSQL service |

---

## Testing Checklist

- [ ] Application starts with `SPRING_PROFILES_ACTIVE=h2`
- [ ] Application starts with `SPRING_PROFILES_ACTIVE=postgresql`
- [ ] All 4 business tables created correctly on PostgreSQL
- [ ] Flowable engine tables created on PostgreSQL
- [ ] Document save/retrieve works
- [ ] Grid rows save/retrieve works
- [ ] Column mapping persists correctly
- [ ] Process config settings persist

---

## Connection String Format

PostgreSQL connection string format:
```
jdbc:postgresql://[host]:[port]/[database]?[parameters]
```

Example:
```
jdbc:postgresql://db.example.com:5432/flowable?sslmode=require
```

Common parameters:
- `sslmode=require` - Enforce SSL connection
- `currentSchema=myschema` - Set default schema
- `connectTimeout=10` - Connection timeout in seconds

---

## Rollback Strategy

If issues arise:
1. Set `SPRING_PROFILES_ACTIVE=h2` to revert to H2
2. H2 data remains in `./data/flowabledb` directory
3. No code changes required for rollback

---

## Production Considerations

1. **Backup Strategy**: Set up pg_dump scheduled backups
2. **SSL/TLS**: Use `sslmode=require` for secure connections
3. **Connection Pooling**: Tune HikariCP based on load
4. **Monitoring**: Enable pg_stat_statements for query analysis
5. **Schema Migrations**: Consider Flyway or Liquibase for future migrations
